# 反思
前几天病了，就没有精力来写，今天感觉状态不错，就更新一点。
之前两篇，实现了两个小挑战，针对的都是字符串的操作，但我一直也没有系统的将字符串以及它的特性来描述一下，这个是我的失误，我应当写在前面的。
## 字符串
字符，我更希望你去把他当成我们人类的文字去理解；字符串，就是一堆文字的集合。
因此字符串有三种表达方式（类比我们的句子，段落）：
* `var1 = 'Hello World!'`
* `var2 = "Python Programming"`
* 还有三引号的，只不过三引号可以是多行的。

> 在此，有一些叫转义字符串，我希望你能去自己百度一下。
我给个简单的例子，在字符串中想表示空格及回车，可以用：`\s`和`\n`

### 查看及操作字符串
就想象成对我们的句子来进行操作，如下表：
a = "Hello" b = "Python"

操作符 |	 描述	| 例子
----------------|----------|---------------
+	 |串联 - 添加操作两边的值	| a + b --> HelloPython
*	 |重复 - 就是重复n遍，会得到一个新字符串 |	 a*2 --> -HelloHello
[]	|切片 - 从给定的索引字符	| a[1] --> e
[ : ]	| 范围切片 - 从给定范围内的字符	| a[1:4] ---> ell
in	| 成员关系 - 返回true，如果存在一个字符在给定的字符串|	H in a --> 1
not in|	 成员关系 - 返回true如果不存在一个字符在给定的字符串|	M not in a --> 1
%	 |格式化 - 执行字符串格式	|  看下面

#### %格式化
Python的最酷的功能之一是字符串格式符％。这个操作符是唯一的字符串，从C的printf（）系列函数的包。
> 我们可以将这个功能想象成占位子，先用一个符号把那个位置占掉，然后再用真正的补上，比如下面：

`print "My name is %s and weight is %d kg!" % ('Zara', 21)`
这将输出以下结果：
`My name is Zara and weight is 21 kg!`

### 别的字符串
#### 原始字符串
什么是原始字符串呢？可以这么认为，就是去掉所有的加工，比如，你在转述别人跟你说的__原话__时，你会说，他是这么说的：‘’，你就相当输出了原始字符串！
python中也一样：`print(r'C:\\nowhere')`
你要知道，如果不加`r`，那两个`\\`是只能输出一个的，那是转义符，（让你自己百度了！）
但加了`r`就会把原始的字符串输出，相当于去掉了转述人的理解。
#### Unicode字符串
存储字节的位数不同，在python中，正常字符串在内部存储为8位ASCII，Unicode字符串存储为16位Unicode。这使得更加多样化的字符集，包括在世界上大多数语言的特殊字符。用法如下：
`print(u'Hello, world!')`
> 因为不想讲太多无趣的东西，至于为什么要有16位的存储，有兴趣就去百度。

## 字符串的方法
python的字符串方法众多，详细的可以查看官方手册，网址在[这里](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str)
,我把常用的写了出来、（今天就要用到哦）：

method | description
----------|------------------
string.count(str, beg=0, end=len(string))| 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数
string.endswith(obj, beg=0, end=len(string))| 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.
string.find(str, beg=0, end=len(string))| 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1
string.index(str, beg=0, end=len(string))| 跟find()方法一样，只不过如果str不在 strin
string.join(seq)| 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串
string.replace(str1, str2,  num=string.count(str1))| 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.
string.split(str="", num=string.count(str))|  str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串

> 可以注意到，方法我讲的不细，其实很简单，因为概念很重要，要讲的细一些，等理解了之后，方法呢？是具体怎么用，不明白的百度一下就好了。


## 今天的挑战
网址：http://www.pythonchallenge.com/pc/def/ocr.html

打开之后会有如下的图片：
![challenge3](http://www.pythonchallenge.com/pc/def/ocr.jpg)

下面有这么一段话：
> recognize the characters. maybe they are in the book,
but MAYBE they are in the page source.

那我明白了，密码就在页面的源代码中，点右键查看源代码。
> 其实打开之后，可以看出，页面的构造十分简单，你有空可以看看我之前写的“html笔记”，绝对能看懂它的页面源代码

打开之后，发现有一行注释(html的注释符是`!`)
```
<!--
find rare characters in the mess below:
-->
```
找出下面罕见的字符串？
底下是一堆字符串，一堆符号，别的字符，非常乱，就像这样！我们怎么找呢？
```
%%$@_$^__#)^)&!_+]!*@&^}@[@%]()%+$&[(_@%+%$*^@$^!+]!&_#)_*}{}}!}_]$[%}@[{_@#_^{*
@##&{#&{&)*%(]{{([*}@[@&]+!!*{)!}{%+{))])[!^})+)$]#{*+^((@^@}$[**$&^{$!@#$%)!@(&
+^!{%_$&@^!}$_${)$_#)!({@!)(^}!*^&!$%_&&}&_#&@{)]{+)%*{&*%*&@%$+]!*__(#!*){%&@++
!_)^$&&%#+)}!@!)&^}**#!_$([$!$}#*^}$+&#[{*{}{((#$]{[$[$$()_#}!@}^@_&%^*!){*^^_$^
]@}#%[%!^[^_})+@&}{@*!(@$%$^)}[_!}(*}#}#___}!](@_{{(*#%!%%+*)^+#%}$+_]#}%!**#!^_
)@)$%%^{_%!@(&{!}$_$[)*!^&{}*#{!)@})!*{^&[&$#@)*@#@_@^_#*!@_#})+[^&!@*}^){%%{&#@
@{%(&{+(#^{@{)%_$[+}]$]^{^#(*}%)@$@}(#{_&]#%#]{_*({(])$%[!}#@@&_)([*]}$}&${^}@(%
```
### 思路
没关系，记得刚刚讲的python的string的method中有一个`count()`函数吗？
> string.count(str, beg=0, end=len(string)) : 返回str在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数

这样的话，我们就有思路了：去对每个出现的字符进行计数（count），最少的就是我们要的！

### 实现
第一步：建立`c3.py`
第二步：`origintext ="   "`将源代码中那一堆字符串，给复制进去。
第三步：`handed = ""`建立一个空的字符串，看它的名字，就是表明它是已经处理过的意思。（我们不想对一堆字符串每一个字符进行比较，我们就把已经比较过的放在一个地方，遇到已经处理过的，就不管！）
第四步：直接上代码：
```python
for i in origintext:
    if i in handed:
        pass
    else:
        handed = handed+ i
        print(i,origintext.count(i))
```
结果如下：
```
% 6104
$ 6046
@ 6157
_ 6112
^ 6030
# 6115
) 6186
& 6043
! 6079
+ 6066
] 6152
* 6034
} 6105
[ 6108
( 6154
{ 6046

 1220
e 1
q 1
u 1
a 1
l 1
i 1
t 1
y 1
```

### 结果
equality就是我们要的结果，因此，将网址中的`ocr`替换为：`equality`即可。

### 待续
这种方法过于繁琐，实际上等以后，我们的知识积累到了一定的水平，我们用爬虫的方法再做一遍，代码更少，运行不一定更快哦，此处留个悬念！
